"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tuplehash256xof = exports.tuplehash256 = exports.tuplehash128xof = exports.tuplehash128 = exports.parallelhash256xof = exports.parallelhash256 = exports.parallelhash128xof = exports.parallelhash128 = exports.m14 = exports.kmac256xof = exports.kmac256 = exports.kmac128xof = exports.kmac128 = exports.keccakprg = exports.k12 = exports.cshake256 = exports.cshake128 = void 0;

var _utils = require("./utils.cjs");

var _sha = require("./sha3.cjs");

// cSHAKE && KMAC (NIST SP800-185)
function leftEncode(n) {
  const res = [n & 0xff];
  n >>= 8;

  for (; n > 0; n >>= 8) res.unshift(n & 0xff);

  res.unshift(res.length);
  return new Uint8Array(res);
}

function rightEncode(n) {
  const res = [n & 0xff];
  n >>= 8;

  for (; n > 0; n >>= 8) res.unshift(n & 0xff);

  res.push(res.length);
  return new Uint8Array(res);
}

const toBytesOptional = buf => buf !== undefined ? (0, _utils.toBytes)(buf) : new Uint8Array([]); // NOTE: second modulo is necessary since we don't need to add padding if current element takes whole block


const getPadding = (len, block) => new Uint8Array((block - len % block) % block);

// Personalization
function cshakePers(hash) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!opts || !opts.personalization && !opts.NISTfn) return hash; // Encode and pad inplace to avoid unneccesary memory copies/slices (so we don't need to zero them later)
  // bytepad(encode_string(N) || encode_string(S), 168)

  const blockLenBytes = leftEncode(hash.blockLen);
  const fn = toBytesOptional(opts.NISTfn);
  const fnLen = leftEncode(8 * fn.length); // length in bits

  const pers = toBytesOptional(opts.personalization);
  const persLen = leftEncode(8 * pers.length); // length in bits

  if (!fn.length && !pers.length) return hash;
  hash.suffix = 0x04;
  hash.update(blockLenBytes).update(fnLen).update(fn).update(persLen).update(pers);
  let totalLen = blockLenBytes.length + fnLen.length + fn.length + persLen.length + pers.length;
  hash.update(getPadding(totalLen, hash.blockLen));
  return hash;
}

const gencShake = (suffix, blockLen, outputLen) => (0, _utils.wrapConstructorWithOpts)(function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return cshakePers(new _sha.Keccak(blockLen, suffix, opts.dkLen !== undefined ? opts.dkLen : outputLen, true), opts);
});

const cshake128 = gencShake(0x1f, 168, 128 / 8);
exports.cshake128 = cshake128;
const cshake256 = gencShake(0x1f, 136, 256 / 8);
exports.cshake256 = cshake256;

class KMAC extends _sha.Keccak {
  constructor(blockLen, outputLen, enableXOF, key) {
    let opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    super(blockLen, 0x1f, outputLen, enableXOF);
    cshakePers(this, {
      NISTfn: 'KMAC',
      personalization: opts.personalization
    });
    key = (0, _utils.toBytes)(key); // 1. newX = bytepad(encode_string(K), 168) || X || right_encode(L).

    const blockLenBytes = leftEncode(this.blockLen);
    const keyLen = leftEncode(8 * key.length);
    this.update(blockLenBytes).update(keyLen).update(key);
    const totalLen = blockLenBytes.length + keyLen.length + key.length;
    this.update(getPadding(totalLen, this.blockLen));
  }

  finish() {
    if (!this.finished) this.update(rightEncode(this.enableXOF ? 0 : this.outputLen * 8)); // outputLen in bits

    super.finish();
  }

  _cloneInto(to) {
    // Create new instance without calling constructor since key already in state and we don't know it.
    // Force "to" to be instance of KMAC instead of Sha3.
    if (!to) {
      to = Object.create(Object.getPrototypeOf(this), {});
      to.state = this.state.slice();
      to.blockLen = this.blockLen;
      to.state32 = (0, _utils.u32)(to.state);
    }

    return super._cloneInto(to);
  }

  clone() {
    return this._cloneInto();
  }

}

function genKmac(blockLen, outputLen) {
  let xof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  const kmac = (key, message, opts) => kmac.create(key, opts).update(message).digest();

  kmac.create = function (key) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new KMAC(blockLen, opts.dkLen !== undefined ? opts.dkLen : outputLen, xof, key, opts);
  };

  kmac.init = kmac.create;
  return kmac;
}

const kmac128 = genKmac(168, 128 / 8);
exports.kmac128 = kmac128;
const kmac256 = genKmac(136, 256 / 8);
exports.kmac256 = kmac256;
const kmac128xof = genKmac(168, 128 / 8, true);
exports.kmac128xof = kmac128xof;
const kmac256xof = genKmac(136, 256 / 8, true); // TupleHash
// Usage: tuple(['ab', 'cd']) != tuple(['a', 'bcd'])

exports.kmac256xof = kmac256xof;

class TupleHash extends _sha.Keccak {
  constructor(blockLen, outputLen, enableXOF) {
    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    super(blockLen, 0x1f, outputLen, enableXOF);
    cshakePers(this, {
      NISTfn: 'TupleHash',
      personalization: opts.personalization
    }); // Change update after cshake processed

    this.update = data => {
      data = (0, _utils.toBytes)(data);
      super.update(leftEncode(data.length * 8));
      super.update(data);
      return this;
    };
  }

  finish() {
    if (!this.finished) super.update(rightEncode(this.enableXOF ? 0 : this.outputLen * 8)); // outputLen in bits

    super.finish();
  }

  _cloneInto(to) {
    to || (to = new TupleHash(this.blockLen, this.outputLen, this.enableXOF));
    return super._cloneInto(to);
  }

  clone() {
    return this._cloneInto();
  }

}

function genTuple(blockLen, outputLen) {
  let xof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  const tuple = (messages, opts) => {
    const h = tuple.create(opts);

    for (const msg of messages) h.update(msg);

    return h.digest();
  };

  tuple.create = function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new TupleHash(blockLen, opts.dkLen !== undefined ? opts.dkLen : outputLen, xof, opts);
  };

  tuple.init = tuple.create;
  return tuple;
}

const tuplehash128 = genTuple(168, 128 / 8);
exports.tuplehash128 = tuplehash128;
const tuplehash256 = genTuple(136, 256 / 8);
exports.tuplehash256 = tuplehash256;
const tuplehash128xof = genTuple(168, 128 / 8, true);
exports.tuplehash128xof = tuplehash128xof;
const tuplehash256xof = genTuple(136, 256 / 8, true); // ParallelHash (same as K12/M14, but without speedup for inputs less 8kb, reduced number of rounds and more simple)

exports.tuplehash256xof = tuplehash256xof;

class ParallelHash extends _sha.Keccak {
  // Position of current block in chunk
  // How many chunks we already have
  constructor(blockLen, outputLen, leafCons, enableXOF) {
    let opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    super(blockLen, 0x1f, outputLen, enableXOF);
    this.leafCons = leafCons;
    this.leafHash = void 0;
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.chunkLen = void 0;
    cshakePers(this, {
      NISTfn: 'ParallelHash',
      personalization: opts.personalization
    });
    let {
      blockLen: B
    } = opts;
    B || (B = 8);
    (0, _utils.assertNumber)(B);
    this.chunkLen = B;
    super.update(leftEncode(B)); // Change update after cshake processed

    this.update = data => {
      data = (0, _utils.toBytes)(data);
      const {
        chunkLen,
        leafCons
      } = this;

      for (let pos = 0, len = data.length; pos < len;) {
        if (this.chunkPos == chunkLen || !this.leafHash) {
          if (this.leafHash) {
            super.update(this.leafHash.digest());
            this.chunksDone++;
          }

          this.leafHash = leafCons();
          this.chunkPos = 0;
        }

        const take = Math.min(chunkLen - this.chunkPos, len - pos);
        this.leafHash.update(data.subarray(pos, pos + take));
        this.chunkPos += take;
        pos += take;
      }

      return this;
    };
  }

  finish() {
    if (this.finished) return;

    if (this.leafHash) {
      super.update(this.leafHash.digest());
      this.chunksDone++;
    }

    super.update(rightEncode(this.chunksDone));
    super.update(rightEncode(this.enableXOF ? 0 : this.outputLen * 8)); // outputLen in bits

    super.finish();
  }

  _cloneInto(to) {
    to || (to = new ParallelHash(this.blockLen, this.outputLen, this.leafCons, this.enableXOF));
    if (this.leafHash) to.leafHash = this.leafHash._cloneInto(to.leafHash);
    to.chunkPos = this.chunkPos;
    to.chunkLen = this.chunkLen;
    to.chunksDone = this.chunksDone;
    return super._cloneInto(to);
  }

  destroy() {
    super.destroy.call(this);
    if (this.leafHash) this.leafHash.destroy();
  }

  clone() {
    return this._cloneInto();
  }

}

function genParallel(blockLen, outputLen, leaf) {
  let xof = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  const parallel = (message, opts) => parallel.create(opts).update(message).digest();

  parallel.create = function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new ParallelHash(blockLen, opts.dkLen !== undefined ? opts.dkLen : outputLen, () => leaf.init({
      dkLen: 2 * outputLen
    }), xof, opts);
  };

  parallel.init = parallel.create;
  return parallel;
}

const parallelhash128 = genParallel(168, 128 / 8, cshake128);
exports.parallelhash128 = parallelhash128;
const parallelhash256 = genParallel(136, 256 / 8, cshake256);
exports.parallelhash256 = parallelhash256;
const parallelhash128xof = genParallel(168, 128 / 8, cshake128, true);
exports.parallelhash128xof = parallelhash128xof;
const parallelhash256xof = genParallel(136, 256 / 8, cshake256, true); // Kangaroo
// Same as NIST rightEncode, but returns [0] for zero string

exports.parallelhash256xof = parallelhash256xof;

function rightEncodeK12(n) {
  const res = [];

  for (; n > 0; n >>= 8) res.unshift(n & 0xff);

  res.push(res.length);
  return new Uint8Array(res);
}

const EMPTY = new Uint8Array([]);

class KangarooTwelve extends _sha.Keccak {
  // Position of current block in chunk
  // How many chunks we already have
  constructor(blockLen, leafLen, outputLen, rounds, opts) {
    super(blockLen, 0x07, outputLen, true, rounds);
    this.leafLen = leafLen;
    this.chunkLen = 8192;
    this.leafHash = void 0;
    this.personalization = void 0;
    this.chunkPos = 0;
    this.chunksDone = 0;
    const {
      personalization
    } = opts;
    this.personalization = toBytesOptional(personalization);
  }

  update(data) {
    data = (0, _utils.toBytes)(data);
    const {
      chunkLen,
      blockLen,
      leafLen,
      rounds
    } = this;

    for (let pos = 0, len = data.length; pos < len;) {
      if (this.chunkPos == chunkLen) {
        if (this.leafHash) super.update(this.leafHash.digest());else {
          this.suffix = 0x06; // Its safe to change suffix here since its used only in digest()

          super.update(new Uint8Array([3, 0, 0, 0, 0, 0, 0, 0]));
        }
        this.leafHash = new _sha.Keccak(blockLen, 0x0b, leafLen, false, rounds);
        this.chunksDone++;
        this.chunkPos = 0;
      }

      const take = Math.min(chunkLen - this.chunkPos, len - pos);
      const chunk = data.subarray(pos, pos + take);
      if (this.leafHash) this.leafHash.update(chunk);else super.update(chunk);
      this.chunkPos += take;
      pos += take;
    }

    return this;
  }

  finish() {
    if (this.finished) return;
    const {
      personalization
    } = this;
    this.update(personalization).update(rightEncodeK12(personalization.length)); // Leaf hash

    if (this.leafHash) {
      super.update(this.leafHash.digest());
      super.update(rightEncodeK12(this.chunksDone));
      super.update(new Uint8Array([0xff, 0xff]));
    }

    super.finish.call(this);
  }

  destroy() {
    super.destroy.call(this);
    if (this.leafHash) this.leafHash.destroy(); // We cannot zero personalization buffer since it is user provided and we don't want to mutate user input

    this.personalization = EMPTY;
  }

  _cloneInto(to) {
    const {
      blockLen,
      leafLen,
      leafHash,
      outputLen,
      rounds
    } = this;
    to || (to = new KangarooTwelve(blockLen, leafLen, outputLen, rounds, {}));

    super._cloneInto(to);

    if (leafHash) to.leafHash = leafHash._cloneInto(to.leafHash);
    to.personalization.set(this.personalization);
    to.leafLen = this.leafLen;
    to.chunkPos = this.chunkPos;
    to.chunksDone = this.chunksDone;
    return to;
  }

  clone() {
    return this._cloneInto();
  }

} // Default to 32 bytes, so it can be used without opts


const k12 = (0, _utils.wrapConstructorWithOpts)(function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new KangarooTwelve(168, 32, opts.dkLen !== undefined ? opts.dkLen : 32, 12, opts);
}); // MarsupilamiFourteen

exports.k12 = k12;
const m14 = (0, _utils.wrapConstructorWithOpts)(function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new KangarooTwelve(136, 64, opts.dkLen !== undefined ? opts.dkLen : 64, 14, opts);
}); // https://keccak.team/files/CSF-0.1.pdf
// + https://github.com/XKCP/XKCP/tree/master/lib/high/Keccak/PRG

exports.m14 = m14;

class KeccakPRG extends _sha.Keccak {
  constructor(capacity) {
    (0, _utils.assertNumber)(capacity); // Rho should be full bytes

    if (capacity < 0 || capacity > 1600 - 10 || (1600 - capacity - 2) % 8) throw new Error('KeccakPRG: Invalid capacity'); // blockLen = rho in bytes

    super((1600 - capacity - 2) / 8, 0, 0, true);
    this.rate = void 0;
    this.rate = 1600 - capacity;
    this.posOut = Math.floor((this.rate + 7) / 8);
  }

  keccak() {
    // Duplex padding
    this.state[this.pos] ^= 0x01;
    this.state[this.blockLen] ^= 0x02; // Rho is full bytes

    super.keccak();
    this.pos = 0;
    this.posOut = 0;
  }

  update(data) {
    super.update(data);
    this.posOut = this.blockLen;
    return this;
  }

  feed(data) {
    return this.update(data);
  }

  finish() {}

  digestInto(out) {
    throw new Error('KeccakPRG: digest is not allowed, please use .fetch instead.');
  }

  fetch(bytes) {
    return this.xof(bytes);
  } // Ensure irreversibility (even if state leaked previous outputs cannot be computed)


  forget() {
    if (this.rate < 1600 / 2 + 1) throw new Error('KeccakPRG: rate too low to use forget');
    this.keccak();

    for (let i = 0; i < this.blockLen; i++) this.state[i] = 0;

    this.pos = this.blockLen;
    this.keccak();
    this.posOut = this.blockLen;
  }

  _cloneInto(to) {
    const {
      rate
    } = this;
    to || (to = new KeccakPRG(1600 - rate));

    super._cloneInto(to);

    to.rate = rate;
    return to;
  }

  clone() {
    return this._cloneInto();
  }

}

const keccakprg = function () {
  let capacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 254;
  return new KeccakPRG(capacity);
};

exports.keccakprg = keccakprg;