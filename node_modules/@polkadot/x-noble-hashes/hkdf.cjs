"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hkdf = void 0;
exports.hkdf_expand = hkdf_expand;
exports.hkdf_extract = hkdf_extract;

var _utils = require("./utils.cjs");

var _hmac = require("./hmac.cjs");

// prettier-ignore
// HKDF (RFC 5869)
// HKDF-Extract(IKM, salt) -> PRK NOTE: arguments position differs from spec (IKM is first one, since it is not optional)
function hkdf_extract(hash, ikm, salt) {
  (0, _utils.assertHash)(hash); // NOTE: some libraries treats zero-length array as 'not provided', we don't, since we have undefined as 'not provided'
  // More info: https://github.com/RustCrypto/KDFs/issues/15

  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros

  return (0, _hmac.hmac)(hash, (0, _utils.toBytes)(salt), (0, _utils.toBytes)(ikm));
} // HKDF-Expand(PRK, info, L) -> OKM


const HKDF_COUNTER = new Uint8Array([0]);
const EMPTY_BUFFER = new Uint8Array();

function hkdf_expand(hash, prk, // a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
info) {
  let length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
  (0, _utils.assertHash)(hash);
  (0, _utils.assertNumber)(length);
  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');
  const blocks = Math.ceil(length / hash.outputLen);
  if (info === undefined) info = EMPTY_BUFFER; // first L(ength) octets of T

  const okm = new Uint8Array(blocks * hash.outputLen); // Re-use HMAC instance between blocks

  const HMAC = _hmac.hmac.init(hash, prk);

  const HMACTmp = HMAC._cloneInto();

  const T = new Uint8Array(HMAC.outputLen);

  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1; // T(0) = empty string (zero length)
    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)

    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash.outputLen * counter);

    HMAC._cloneInto(HMACTmp);
  }

  HMAC.destroy();
  HMACTmp.destroy();
  T.fill(0);
  return okm.slice(0, length);
} // Extract+Expand


const hkdf = (hash, ikm, salt, info, length) => hkdf_expand(hash, hkdf_extract(hash, ikm, salt), info, length);

exports.hkdf = hkdf;